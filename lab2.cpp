/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/

#include <iostream>
#include <tchar.h>
//2.1
#define _USE_MATH_DEFINES //необходимо определить _USE_MATH_DEFINES для подключения файла
#include <math.h> 
//include <cmath> for c++, <math.h> for c

using std::cout;

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
int main()
{
	// ********************************************************
		//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
		//1.1
	{
		std::cout << "task 1.1" << std::endl;
		int y = 9;//Задайте значение y, например, с помощью потока ввода
		//std::cin >> y;
		//С помощью побитовых операторов и операторов сдвига выведите значение "y"
		//на консоль в двоичном виде, например:
		//если y==9, то
		// а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)
		 unsigned int Mask = 0x80000000;
		 for (int i = 31; i >= 0; i--) 
		 {
			 int bit = y & Mask;  
			 bit = bit >> i; //текущий ("проверяемый") бит находится в самой правой позиции
			 std::cout << (bit);
			 Mask = Mask >> 1; //проверяем каждый бит числа
		 }
		 std::cout << ' ' << std::endl;

		//или пропустите незначащие нули - б) 1 0 0 1
		unsigned int Mask_1 = 0x80000000;
		bool Flag = false; //флаг поднимается, когда впервые встречается единица
		for (int i = 31; i >= 0; i--)
		{
			int bit = y & Mask_1;
			bit = bit >> i;
			if (bit == 0 and Flag==false) {} //проверка на нулевые биты до первого значащего бита
			else {
				Flag = true;
				std::cout << (bit);
			}
			Mask_1 = Mask_1 >> 1;
		}
		std::cout << ' ' << std::endl;

	}
	

	//1.2 Дана целая переменная

	{
	std::cout << "task 1.2" << std::endl;
		unsigned int Mask_2 = 0x80000000;
		int y = 1325428482; //0100 1111 0000 0000 0110 1111 0000 0010
		//"Сдвиньте" все единицы в этой переменной вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
		int new_y = 0;
		for (int i = 31; i >= 0; i--)
		{
			int bit = y & Mask_2;
			bit = bit >> i; 
			Mask_2 = Mask_2 >> 1;
			if (bit != 0) { new_y = (new_y << 1) + 1; }
		}
		std::cout << new_y << std::endl;
		//new_y = 4095 (0000 0000 0000 0000 0000 1111 1111 1111)
	}


	//1.3* Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
		short sNum = 0x8008; //1000 0000 0000 1000
		short sRes;

		//0x7ff7 = 0111 1111 1111 0111
		sRes = ~sNum;  /* тут побитовая операция и операнд, чтобы получить число 0x7ff7 */;

		//0x8ff8 = 1000 1111 1111 1000
		sRes = sNum | 0x0ff0;

		//0x0008 = 0000 0000 0000 1000
		sRes = sNum & 0x0008;

		//0x7f08 = 0111 1111 0000 1000
		sRes = sNum ^ 0xff00;

		//0xf001 = 1111 0000 0000 0001
		sRes = static_cast<signed short>(sNum) >> 3;

		//0x0010 = 0000 0000 0001 0000
		sRes = static_cast<unsigned short>(sNum) >> 11;

		stop
	}


	// ********************************************************
		//Задание 2. Директивы препроцессора

		//2.1. Использование "математических" макросов стандартной библиотеки:
		//в заголовочном файле <cmath> (который в свою очередь включает старый
		//файл math.h) определены часто используемые математические
		//константы, например M_PI. Воспользуйтесь этой константой для
		//вычисления длины окружности.
		//Обратите внимание: определения констант в свою очередь тоже заключены
		//в директивы условной трансляции. Что еще, кроме подключения заголовочного
		//файла, требуется сделать???

	{
		using namespace std;
		double len, radius;
		std::cout << "task 2.1" << std::endl;
		//std::cin >> radius;
		radius = 2.5;
		len = 2 * radius * M_PI;
		std::cout << "length = " << len << std::endl;
	}

		



		//2.2.Макросы с параметрами.
		//2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
		// протестируйте написанный макрос для следующих ситуаций:
	{
		#define LENGHT(len) (static_cast<float>(len)*M_PI*2)
		//using namespace std;
		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...
		#undef LENGTH
		stop
	}




	//2.2.2* определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.

	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	
#define MAX(A, B) (A>=B ? A : B)

	int i = 10, j = 12, k;
	k = MAX(i, j); // k=12 (i=10, j=12)
	k = MAX(j, i) * 2; // k=12*2=24 (i=10, j=12)
	k = MAX(j, i+3); // k=13 (i+3=13, j=12)
	k = MAX(i--, j++); // k=13 (i=9, j=14)  
	//постфиксный инкремент/дискремент происходит после вычисления выражения
	//т.е. на вычисление подаются исходные числа, а потом они изменяются
	//k = MAX(--i, ++j); //k=14 (i=9, j=14) - правильно
	//в этом случае используем префиксный инкремент/дискремент, он происходит до вычисления выражения
#undef MAX
//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
//двух объектов типа int в памяти местами. Проверьте для приведенного
//фрагмента. Подумайте, что будет делать макроподстановка, если
//переставляемые значения разного типа???
	//если подставляемые значения разного типа, производится неявное приведение типов данных 
#define EXCHANGE(X, Y) {int ex = X; X = Y; Y = ex;}

	int x1=1, y1=-1;
	EXCHANGE(x1,y1);

	int x2=100, y2=-100;
	EXCHANGE(x2,y2);

#undef EXCHANGE

	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

// при начальных условиях iNN принимает значение -1, т.к. макросы NNN и MMM не определены 
/* iNN = 0
	#define MMM
	#define NNN */
/* iNN = 1
	#define MMM */
/* iNN = 2
	#define NNN */
int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN
	iNN = 2;

#else
	iNN = -1;
#endif

	stop



		//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
		//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
		//В опциях командной строки в зависимости от мишени сборки проекта
		//(Debug или Release) может быть определено с помощью ключа /D
		//имя _DEBUG. С помощью директив условной
		//трансляции напишите фрагмент кода, который в зависимости от типа
		//мишени выводит с помощью cout разный текст на консоль. Проверьте
		//при разных мишенях сборки.
std::cout << "task 2.4" << std::endl;
//Пусть
//для мишени Debug в процессе выполнения данного участка
//кода на экран выводится информация об
//имени файла, номере строки с функцией вывода, дате и времени 
//компиляции файла, содержащего данную функцию вывода,
//а также имя функции, содержащей данную строку.
//Для мишени Release должна быть просто выведена строка
//"Release configuration!"

#ifdef _DEBUG
	std::cout << "Name: " << __FILE__ << std::endl;
	std::cout << "Date: " << __DATE__ << std::endl;
	std::cout << "Time: " << __TIME__ << std::endl;
	std::cout << "Line: " << __LINE__ << std::endl; 
#else
	std::cout << "Release configuration!" << std::endl;
#endif

//Подсказка: для получения нужной информации введите в инструментальном
//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros

//Подсказка: мишень сборки проекта можно
//поменять следующим образом - Build/Configuration Manager/Configuration



//Задание 2.5.* Управляя определенностью идентификатора _UNICODE и используя
//возможности заголовочного <tchar.h>, определите и проинициализируйте переменную,
//которая может становиться как однобайтовой, так и расширенной без 
//изменения исходного текста.
//С помощью отладчика проверьте результат.
using namespace std;
#define _UNICODE
//#undef _UNICODE
#ifdef _UNICODE
		wchar_t my;
#else
		char my;
#endif
my = 's';
std::cout << "task 2.5: " << sizeof(my) << std::endl;






// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

#ifdef _DEBUG
		#include "1.h"
#else
		#include "2.h"
#endif
std::cout << "task 3.1" << std::endl;
std::cout << "My1 = " << My1 << std::endl;
std::cout << "My2 = " << My2 << std::endl;
std::cout << "My3 = " << My3 << std::endl;


// ********************************************************
	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов.
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
{
	int aInt = 2;
	float bFloat = 2.67;
	double cDouble = 3.0005;
	char dChar = 'a';
	short eShort = 10;

	int* p_aInt = &aInt; //0x00aff910 {2} указывает на aInt
	float* p_bFloat = &bFloat; //0x00aff904 {2.67000008} указывает на bFloat 
	double* p_cDouble = &cDouble; //0x00aff8f4 {3.0005000000000002} указывает на cDouble
	char* p_dChar = &dChar; //0x00aff8eb "aММММММММ\x1b/Э$\x6\x1\b@ММММММММHб*@ММММММММ\x2" указывает на dChar
	short* p_eShort = &eShort; //0x00aff8dc {10} указывает на eShort
}


	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
{
	char strok[] = "hello"; //строковый литерал (массив)
	char* p_str = strok; //инициализируем указатель адресом первого элемента массива 
	char prob_str = p_str[2]; //prob_str = l

	const char * str = "hello";
	//char* p2_str = &strok; //невозможно присвоить значение по адресу strok из-за несоответствия типов
	// p2_str - указатель на указатель на тип char, поэтому правильный вариант
	// char** p2_str = &strok;
	// p2_str инициализируется адресом массива strok

}

	stop



	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3}; //инициализирован массив с элементами {1, 3, 0} типа int
		int* pn = &nAr[0]; //указатель pn указывает на первый элемент массива (1)
		(*pn)++; //с помощью операции разыменования * получаем значение, на которое указывает указатель pn
		//и увеличиваем его на 1: 1+1=2
		pn++; //увеличиваем указатель pn, который перемещается на второй элемент массива (3)

		char cAr[]={'A','B','C','D'}; //инициализирован массив с элементами типа char
		char* pc = &cAr[0]; //указатель указывает на первый элемент массива ('A')
		(*pc)=(*pc)+5; //значение по адресу, на который указывает pc, увеличивается на 5: 65+5=70 ('F')
		pc=pc+3; //увеличиваем указатель pc, который перемещается на четвертый элемент массива ('D')

		double dAr[3]={1.0,2.0}; //инициализирован массив с элементами типа double
		double* pd1 = &dAr[0]; //указатель указывает на первый элемент массива (1.0000000000000000)
		double* pd2 = pd1; //адрес dAr[0] копируется в указатель pd2 
		(*pd2)+=2; //значение по адресу, на который указывает pd2, увеличивается на 2: 3.0000000000000000
		pd2+=2; //увеличиваем указатель pd2, который перемещается на третий элемент массива (0.0000000000000000)

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0]; //указатель указывает на первый элемент массива
		pd2 = &dAr[1]; //указатель указывает на второй элемент массива
		int nNumber=pd2 - pd1; //разница (в элементах) между указателями pd2 и pd1 

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		std::cout << "task 5" << std::endl;
		char sravn;
		if (pd1 > pd2) { sravn = '>'; }
		else if (pd1 = pd2) { sravn = '='; }
		else { sravn = '<'; }
		std::cout << "pd1" << sravn << "pd2" << std::endl;
		stop
	}


	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт.
	//Следовательно, возникает необходимость явного преобразования
	//указателя.
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

	unsigned int nObject5=0x55667788; //0x55667788 (16cc)
	unsigned int* pnObject5=&nObject5; //указатель типа unsigned int* на nObject5

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование
	//"легальным" (безопасным)
	unsigned char* pucObject5; //указатель типа unsigned char*
//static_cast: невозможно преобразовать "unsigned int *" в "unsigned char *"
//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	// pucObject5 = 0x00dcfa14 "€wfUМММММММММММ=ММММММММ\x1"
	char cc = *(pucObject5++); //cc = 0x88 '€', p = 0x00dcfa14 +1 = 0x00dcfa15 
	//сначала с помощью операции разыменования из указателя извлекается значение
	//а потом с помощью операции постинкремента указатель увеличивается на 1 (т.е. смещается на следующий байт)

	cc = (*pucObject5)++;//cc = 0x77 'w', p = 0x00dcfa15
	//сначала с помощью операции разыменования из указателя извлекается значение
	//затем значение увеличивается на 1, указатель остается неизменным (указывает на тот же байт)

	cc = ++*(pucObject5); //cc = 0x79 'y'; p = 0x00dcfa15
	//происходит преинкремент значения байта, на который указывает указатель
	//указатель не меняет своего положения

	cc = *(++pucObject5); //cc = 0x66 'f'; p = 0x00dcfa16
	//сначала происходит преинкремент указателя (т.е. он смещается на следующий байт)
	//затем происходит разыменование указателя и из него извлекается значение следующего байта
	stop


	//Задание 7. Void-указатель.
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5; //адрес 0x00aff6a4 
	char cObject3='A'; //адрес 0x00aff69b 
	int*	pInt = &nObject3; //указатель типа int* на переменную pInt, приваивается значение 5
	pVoid=&nObject3; //указателю присваивается значение 5
	pVoid=&cObject3; //указателю присваивается значение 'A'
	pVoid=pInt; //указателю присваивается значение 5

	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		void const * pn = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу
	//указателя на int (2)

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1) присваивается адрес объекта типа double (0x00aff6a4)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2)присваивается только часть адреса (0x70a3d70a)
	//т.к. double и int имеют разную размерность в памяти
	stop



		//Задание 8*. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель
		// 
		//Задание 8a. Указатель является константой.
		int perem1 = 20;
		int* const p_perem1 = &perem1; //инициализируем const указатель
		*p_perem1 = 30; //меняем значение по адресу
		//p_perem1++;  //модифицировать такой указатель нельзя

	stop


		//Задание 8б. Указываемое значение является константой.
		const char cpm = 'a';
		const char* p_cpm = &cpm; //инициализируем указатель на const значение
		//*p_cpm += 1; //изменить значение по адресу нельзя, т.к. оно константа
		p_cpm++; //увеличиваем указатель

		stop


		//Задание 8в. И указатель, и указываемое значение
		//являются константами.
		const int cInt = 100;
		const int* const p_cInt = &cInt; //инициализируем const указатель на const значение
		//*p_cInt -= 1; //изменить значение по адресу нельзя, т.к. оно константа
		//p_cInt++ //модифицировать const указатель нельзя

	stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const.
	const int nN = 1;
	//Объявите указатель и проинициализируйте его выражением - &nN
	const int* p_nN = &nN;

	stop



	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

	//Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn = &n1;

	//Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int** ppn = &pn;

	//Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int*** pppn = &ppn;

	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int n2 = *pn; 
	n2 = **ppn; //двойное разыменование: разыменовывается ppn, чтобы получить указатель pn
	//затем разыменовывается указатель pn для получения значения переменной n 
	n2 = ***pppn; // или так: тройное разыменование...


	stop




	return 0;
}//end main