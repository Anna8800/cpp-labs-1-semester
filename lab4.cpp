
/*************************************************************
	Практическое занятие №4. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	Указатели на функции
*************************************************************/
#include <iostream>
#include <tchar.h>
#include <cstdlib>
#include <ctime>
#include <cstdio>
#include <cstdarg>
#include "lab4_other.h"
#include <vld.h>


#define	  stop __asm nop

int _tmain()
{

	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение
	{
		double x = 1.099343;
		double& r = x;
		r++;

		//Раскомментируйте  следующую строчку. Что следует сделать, чтобы
		//linker не выдавал ошибки при создании exe-файла. Подсказка: ref - это
		//внешняя по отношению к данному файлу ссылка!

		//внешняя ссылка проинициализирована в другом файле (lab4_other.cpp) при определении
		//и объявлена в заголовочном файле
		ref++;

		//Раскомментируйте следующую строку. Что следует сделать, чтобы
		//компилятор не выдавал ошибки
		const int& ref1 = 1;
		int&& ref2 = 2;

		//Задан указатель:
		char c = 'A';
		char* pc = &c; //указатель
		char*& refpc = pc; //ссылка на указатель
		//Посредством ссылки на указатель измените
		//а) значение по адресу
		*refpc = 'K';
		//б) сам адрес
		refpc++;
	}



	//Задание 2. Отличия при передаче параметров а) по значению,
	// б) по ссылке, в) по указателю
	//Объявите и определите три функции , которые увеличивают заданное
	//с помощью параметра значение на 1 ( а) - IncByValue(),
	// б) - IncByPointer(), в) - IncByReference() ). 
	//Проверьте правильность с помощью отладчика.
	//
	//Замечание: объявления функций принято помещать в заголовочный файл
	{
		int val = 1;//значение этой переменной должно быть увеличено с помощью
					//каждой из функций на единицу
		val = IncByValue(val);
		IncByPointer(&val);
		IncByReference(val);
		stop


			//Задание 2а. Передача параметров c помощью указателя и по ссылке.
			//Перегруженные имена функций.
			//Создайте функцию (функции) swap(), которая меняет значения
			//переменных nX и nY местами.
			// а)Функция должна принимать два указателя на int, оперируя с
			//которыми менять значения переменных в вызывающей программе
			// б)Функция должна принимать две ссылки на int
			//Проверьте правильность с помощью приведенного ниже фрагмента.

			int	nX = 1;
		int nY = -1;
		swap(&nX, &nY);	//поменяли местами значения nX и nY с
							//помощью указателей на nX и nY
		swap(nX, nY);	//а теперь обратно с помощью ссылок на nX и nY
		stop
	}
	{
		//Задание 3. Указатели на массивы в качестве аргументов.
		//3a.Напишите два варианта функции поиска минимального элемента
		//1. во встроенном двухмерном массиве
		//2. в динамическом двухмерном массиве (обе размерности вычисляются)
		std::cout << "task 3a" << std::endl;
		//1.Например:
		// N и M заданы в заголовочном файле
		int ar[][M] = { {34, 78, 18, 90, 26}, {12, 87, 38, 31, 92}, {9, 23, 83, 16, 33}, {15, 56, 52, 45, 97} };
		int res = findMin(ar, sizeof(ar) / sizeof(ar[0]));
		std::cout << "Min element in arr: " << res << std::endl;

		//2. динамический двухмерный массив
		int dynrow, dyncol;
		srand(static_cast<int>(time(0)));
		dynrow = rand() % 10 + 1; //ограничим рандомные числа до 10, чтобы не получить слишком большую матрицу
		dyncol = rand() % 10 + 1;
		int* p = new int[dynrow * dyncol];
		int** pp = new int* [dynrow];
		for (int i = 0; i < dynrow; i++) //заполняем массив рандомными числами
		{
			pp[i] = p + i * dyncol;
			for (int j = 0; j < dyncol; j++)
			{
				pp[i][j] = rand() % 100;
				std::cout << pp[i][j] << " ";
			}
			std::cout << std::endl;
		}
		int resdyn = findMin(pp, dynrow, dyncol);
		std::cout << "Min element in dynamic arr: " << resdyn << std::endl;
		delete[] pp;
		delete[] p;

		//3b. Напишите функцию сравнения двух строк - MyStrCmp():
		//Функция должна принимать два указателя на сравниваемые
		//строки (возможно Вы должны указать компилятору, что функция
		//не имеет права модифицировать содержимое строк)
		//Функция должна возвращать отрицательное значение, если
		//первая строка лексиграфически меньше второй, 0 - если
		//они равны и положительное значение, если первая строка
		//больше второй.
		//Вспомните, что признаком конца строки является нулевой байт.
		std::cout << "task 3b" << std::endl;

		//Создайте две строки для сравнения:
		char str_a[6] = "Hello";
		char str_b[6] = "Cofee";
		//Вызовите функцию сравнения
		int resS = MyStrCmp(str_a, str_b);
		//Выведите результат сравнения с помощью cout:
		std::cout << resS << std::endl;
		stop
	}
	{
		//Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
		//массив в качестве параметра функции.
		//Напишите две взаимодополняющие друг друга функции:
		//1.  ... DayOfYear(...)
		//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
		//в порядковый день года(возвращаемое значение)
		//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
		// (принимает год и порядковый день года в качестве параметров и должна сформировать
		// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
		std::cout << "task 4" << std::endl;
		//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
		int day = 5;
		int month = 3;
		int year = 2019;

		//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
		//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
		//данные приведенного ниже двухмерного массива nDayTab

		int nDayTab[2][12] = {
			{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
			{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

		//Вызов функции DayOfYear
		int day_of_year = DayOfYear(day, month, year, nDayTab);
		std::cout << "Day of year: " << day_of_year << std::endl;

		//Проверка результата обратной функцией DayOfMonth
		int Day;
		int Month = 0;
		DayOfMonth(day_of_year, Month, year, nDayTab, &Day, &Month);
		std::cout << "Day " << Day << ", month " << Month << std::endl;
		stop
	}
	{
		//Задание 5. Создайте одномерный массив (размерность вычисляется в процессе
		//выполнения программы), заполните его значениями.
		//Напишите функцию, которая добавляет в массив новое значение только при условии,
		//что такого значения в массиве еще нет. Подсказка: при этом размер
		//массива должен увеличиться!
		//Для проверки напишите функцию, которая выводит значения всех элементов на экран
		std::cout << "task 5" << std::endl;
		int new_element;
		int size = 5; //актуальный размер, который мы будем изменять
		int* unic_arr = new int [size];
		for (int i = 0; i < size; i++) {
			unic_arr[i] = rand() % 20;
		}
		for (int s = 0; s < 5; s++) {
			std::cin >> new_element;
			Unique_Value(unic_arr, size, new_element);
		}
		Print_arr(unic_arr, size);
		delete[] unic_arr;
	}
	{
		//Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
		//суммы первых N натуральных чисел.
		std::cout << "task 6" << std::endl;
		int N;
		std::cin >> N;
		int recurs_res = Recursive_f(N);
		std::cout << recurs_res << std::endl;
	}
	{
		//Задание 7а. Функции с переменным числом параметров.
		//Напишите функцию (дана заготовка VarArgs, не использующая
		// макросы), которая принимает переменное число аргументов
		// типа int и выводит на печать число принятых параметров и
		// их значения.
		// Признаком конца списка является нулевое значение.
		std::cout << "task 7a" << std::endl;
		int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1, 0);
		VarArgs(nN1, nN2, 0);
		VarArgs(nN1, nN2, nN3, nN4, nN5, 0);
		stop

		//Задание 7б. Модифицируйте функцию 7а с помощью макросов
		// va_start, va_arg, va_end
		std::cout << "task 7b" << std::endl;
		VarArgsMacros(nN1, 0);
		VarArgsMacros(nN1, nN2, 0);
		VarArgsMacros(nN1, nN2, nN3, nN4, nN5, 0);
		stop
	}
	{
		//Задание 8. Возвращение адреса.
		//Напишите функцию, которая находит минимальное значение в массиве,
		// таким образом, чтобы ее вызов можно было использовать слева от знака 
		// равенства: *MyMin(параметры) = 0;
		std::cout << "task 8" << std::endl;
		int arr_for_min[] = { 5, 15, 3, -10, 67, 24 };
		int length = 6;
		//Если функция возвращает адрес, то ее вызов можно использовать как lvalue
		*MyMin(arr_for_min, length) = 0;
		Print_arr(arr_for_min, length);
	}
	return 0;
}
