/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность
	закомментированных блоков, которые требуется последовательно раскомментировать,
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к.
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что
			исполняемый код будет содержать информацию для отладчика -
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или
		просто кликните левой кнопкой на левой серой полосе окна редактирования;
	5. запустите программу в режиме отладки
		(Debug/Start... или  F5);

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода

int nTwin = 1;			//глобальная переменная
namespace TwinSpace { int nTwin = 2; }	//переменная объявлена в
						//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{

	//**********************************************************
	   //Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	   //следите за значениями переменных и интерпретируйте результат (помните, что 
	   //количество байт, отводимых под int, системо-зависимо).
	   //Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	   //данных, а также на внутреннее представление отрицательных целых чисел.

	   //setlocale(LC_CTYPE, "rus");
	//тип char вмещает от -128..127
	char cByte = 'A'; //в cByte символ 'A', кодировка ASCII (65)
	cByte = cByte + 3; // по ASCII 'D' (65+3=68)
	cByte = 0x42; //переменной cByte присвоили значение 'B' (66 = 0x42 (16 CC))
	cByte = 42; //переменной cByte присвоили значение '*'(42)
	cByte = 66; //переменной cByte присвоили значение 'B'(66)
	cByte = 0; //переменной cByte присвоили значение 0 '\0'
	cByte = -0; //все еще 0 '\0'
	cByte = -1; //переменной cByte присвоили значение 'я' (-1)
	cByte = 127; //переменной cByte присвоили значение 127 (символ для удаления)
	cByte = cByte + 1; //переменной cByte присвоили значение -128 (128) 'Ђ'(128)
	cByte = 128; //переменной cByte присвоили значение -128 (128) 'Ђ'
	cByte = cByte + 1; //переменной cByte присвоили значение -127 (129) 'Ѓ'
	
	
	cByte = cByte - 1; //переменной cByte присвоили значение -128 (128) 'Ђ' 
	cByte = cByte - 1; //переменной cByte присвоили значение 127 (символ для удаления)

	cByte = -128; //переменной cByte присвоили значение -128 (128) 'Ђ' 
	cByte = 127; //переменной cByte присвоили значение 127 (символ для удаления)
	cByte = -127; //переменной cByte присвоили значение -127 (129) 'Ѓ' 
	//тип unsigned char вмещает 0..255
	unsigned char ucByte = 0x41; //ucByte присвоено значение 65 'A' (65 = 0x41 (16 CC))
	ucByte = 'B'; //ucByte присвоено значение 66 'B'
	ucByte = -1; //ucByte присвоено значение 255 'я' (-1=255)
	ucByte = ucByte + 1; //ucByte присвоено значение'\0' (255+1=256=0)
	ucByte = 255; //ucByte присвоено значение 255 'я'
	ucByte = 255 + 1; //ucByte присвоено значение 0 (255+1=256=0)

	cByte = 500;
	ucByte = 500;

	cByte == ucByte;

					
	//тип int вмещает от -2^31 до 2^31-1				
	int iInt; //объявляем переменную типа int (-858993460)
	iInt = 0xffffffff; // iInt присвоено значение -1 (-1 = 0xffffffff = 4294967295 (2^32-1)
	iInt += 1; //происходит переполнение разрядной сетки, старший разряд результата теряется -> iInt присвоено значение 0)
	iInt = 16; //iInt присвоено значение 16
	iInt = 0xABCDEF98; //значение -1412567144
	//тип unsigned int вмещает 0...2^32-1
	unsigned int uiInt = 0xffffffff; //uiInt=4294967295
	
	float fFloat = 1.f;//переменная fFloat=1.00000000 
	double dDouble = 1.; //переменная dDouble = 1.0000000000000000
	

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.
	// 
	// в типе double 15-17 знаков после запятой, компилятор округляет значение
	// в типе float 6-9 знаков после запятой, компилятор округляет значение
	// инициализатор имеет до 28 знаков после запятой
	//
	double d = 0.1234567890123456789123456789; //реальное значение d=0.12345678901234568
	d = 2.7; //реальное значение d=2.7000000000000002,
	float  f = 0.1234567890123456789123456789; //реальное значение f=0.123456791
	f = 2.7; //реальное значение f = 2.70000005

	d = 1.;  //реальное значение d=1.0000000000000000
	d = 0.999999999999999999999999999999999; //реальное значение d=1.0000000000000000 (округляется)
	
	stop

		// В комментариях напишите результат, возвращаемый оператором sizeof для
		// переменной типа wchar_t (ее размер)
		wchar_t cw = L'Ф'; //wchar для национальных языков
	cw = 'Ф';
	size_t n = sizeof(cw); //возвращаемый результат 2 байта

	stop


		// **************************************************************
			//Задание 2a. Неявное приведение типов данных.
			//Объясните разницу результата при выполнении (1) и (2):
			//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

		iInt = 1;
	double dDouble1 = iInt / 3;		    // (1) 0.0000000000000000 
	//(оба числа типа int, целочисленное деление, которое приводится к типу double)
	double dDouble2 = iInt / 3.;	    // (2) 0.33333333333333331 
	//(оба числа типа double, знаки после запятой сохранятся)
	double dDouble3 = (float)iInt / 3;	// (3) 0.33333334326744080 
	//(тк у типа float меньше точность, чем у типа double, результат получается отличным от (2)


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставьте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble = (fFloat = (iInt = (sShort = (cByte = 3.3 / 3))));			
	//(1) Warning C4244: когда мы присваиваем double (результат вычислений) к char, возможна потеря данных
	// Warning C4244: когда мы присваиваем int к float, возможна потеря данных (int может содержать больше байт, чем float) 
	cByte = (sShort = (iInt = (fFloat = (dDouble = 3.3 / 3))));		
	//(2)Warning C4244: когда мы присваиваем double (8 байт) к float (4 байта), возможна потеря данных 
	//Warning C4244: когда мы присваиваем float к int, возможна потеря данных
	//Warning C4244: когда мы присваиваем int (4) к short (2), возможна потеря данных
	//Warning C4244: когда мы присваиваем short (2) к char (1), возможна потеря данных
	// 
	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор
	iInt = 257;
	cByte = iInt; //257(10сс)=1.0000.0001(2сс)
	//cByte хранит 1 байт информации, т.е. 0000.0001 -> 1
	//если не учитывать количество информации в конкретном типе, можно потерять данные

	unsigned char cN1 = 255, cN2 = 2, cSum;
	cSum = cN1 + cN2; //из-за переполнения разрядной сетки старший разряд результата теряется
	//cSum=1

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1 + cN2; // в типе int числа хранятся от -2^31..2^31-1
	//cN1+cN2 = 257>256, т.е. в типе char получается 1, однако в типе int присваивается 257
	// 1111.1111+0000.0010=1.0000.0001
	// 
	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1 = 0xff, c2 = 2; // char имеет значения -128..127 -> с1=-1, с2=2
	unsigned char uc1 = 0xff, uc2 = 2; // unsigned char имеет значения 0..255 -> uc1=255, uc2=2
	int iSum1 = c1 + c2;   //(1) iSum1=-1+2=1
	int iSum2 = uc1 + uc2; //(2) iSum2=255+2=257

	stop


		// ***********************************************************
			//Задание 2b. Явное приведение типов данных.
			//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
			// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp = 100, nn = 3;
	dDouble = 3.3 +  nTmp / nn; // (3) dDouble = 36.299999999999997
	//т.к. nTmp и nn типа int, то выполняется целочисленное деление 100/3=33
	// далее выполняется сложение и приведение к типу double
	// 
	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
	double dDouble4 = static_cast<double>(nTmp) / nn + 3.3;	// (4) dDouble = 36.633333333333333
	//тип переменной nTmp явно приводится к типу double
	//в выражении появился операнд старшего плавающего типа ->
	//второй операнд будет приведен к тому же типу и деление будет типа double
	//М. Полубенцева (стр.79-80)
	stop


		// *******************************************************
			// Задание 3. Область действия, область видимости и
			//				время существования переменных

			//   В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
			// nTwin - одна глобальная, вторая определена в своем пространстве имен, 
			// (определены выше в начале модуля) третья - локальная внутри функции main(), 
			// четвертая - вложенная локальная внутри блока. 
			//   В данном задании требуется в выделенных местах фрагмента определить, к какой 
			// из четырех переменных идет обращение, а также факт существования и видимости 
			// для всех четырех, заполнив приведенные в задании таблицы 
			//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
			// Подсказка: - в окно "Watches" можно поместить как nTwin
			//			так и ::nTwin, впрочем как и TwinSpace::nTwin


		nTwin = 100; //глобальная переменная (100)
	TwinSpace::nTwin = 300; //переменная в пространстве имен TwinSpace (300)
	nTwin++; //глобальная переменная (101)

	// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
	// до следующей строки еще не определена (и формально даже не существует), но место
	// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
	// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
	// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
	// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
	// Компилятор при этом все вычисляет верно.
	// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
	// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
	// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.

	int nTwin; //локальная переменная внутри функции main() (-858993460)
	nTwin = 200; //локальная переменная внутри функции main() (200)
	::nTwin++; //глобальная переменная (102)
	{
		int nTwin; //локальная переменная внутри блока (-858993460)
		nTwin = -1; //локальная переменная внутри блока (-1)
		::nTwin++; //глобальная переменная (103)
		TwinSpace::nTwin++; //переменная в пространстве имен TwinSpace (301)
	}

	nTwin--; //локальная переменная внутри функции main() (199)


	// *******************************************************
		// Задание 4. Спецификатор класса памяти - static
		// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
		// б) Напишите, когда выполняется инициализация обеих переменных?
		// в) Поясните (в комментарии) разницу между способом инициализации 
		//     переменных nStatic1 и nStatic2 и поясните побочный эффект, 
		//     влияющий на переменную nLocal2.

	for (int i = 0; i < 3; i++)
	{
		// (б) инициализация переменных класса static производится 1 раз
		// и далее сохраняет значение при очередном выполнении блока
		// переменные класса int инициализируются каждый раз при выполнении блока
		// (в) значение nStatic1 инициализируется при первой итерации и сохраняет свое значение до конца программы
		// значение nStatic2 вычисляется только при первой итерации, далее сохраняет свое значение до конца программы
		// nLocal2 в конце первой итерации равен 201 (т.к. вычисляется значение nStatic2)
		// в следующих двух итерациях nLocal2 = 200
		static int nStatic1 = 100; // 1)100 2)101 3)102
		int nLocal1 = 100; // 1)100 2)100 3)100
		int nLocal2 = 200; // 1)200 2)200 3)200
		static int nStatic2 = nLocal2++ * 2; // 1)400 2)401 3)402
		nStatic1++; // 1)101 2)102 3)103 
		nStatic2++; // 1)401 2)402 3)403 
		nLocal1++; // 1)101 2)101 3)101 
		stop

	}
	// Напишите:
	//   а) как изменилось поведение пременной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i = 0; i < 3; i++)
	{
		static int nStatic1; //i=0)переменная не инициализирована 1)101 2)101 
		nStatic1 = 100; //i=0)переменная инициализирована, присвоено значение 100 
		//1)100 2)100
		int nLocal1 = 100;
		nStatic1++; //0)101 1)101 2)101
		nLocal1++;
		stop
	}
	

	char ucCounter = 120;
	int q = static_cast<int>(static_cast<char>(ucCounter) + static_cast<char>(5));
	// так как переменная nStatic1 не инициализируется в строке с static
	// в дальнейших итерациях эта инициализация игнорируется
	// переменная nStatic1 ведет себя как переменная типа int
	// то есть в каждой итерации ей присваивается заданное значение заново
	/*
	for (char i = ucCounter; i < ucCounter + 10; i++)
	{
		static int nStatic1;
		nStatic1 = 100;
		int nLocal1 = 100;
		nStatic1++;
		nLocal1++;
		stop
	}
	*/

	

	// *******************************************************
		// Задание 5. Перечисления - enum
		// Обратите внимание на явную и неявную инициализацию констант
		// Выполняя задание по шагам, следите за значениями, которые
		// принимает переменная myColors


	enum eColors
	{
		BLACK, //0
		BLUE, //1
		GREEN, //2
		RED = 5, //5
		YELLOW, //6
		WHITE = RED + 4 //9
	};

	eColors  myColors;	//объявление переменной типа eColors 
	myColors = BLACK;
	myColors = BLUE;
	myColors = GREEN;
	myColors = RED;
	myColors = YELLOW;
	myColors = WHITE;

	int nnn = BLACK; //любой целочисленной переменной можно присвоить
					 //значение из списка инициализирующих значений
					 //nnn=0
	//Именованные константы можно использовать в выражениях:
	nnn = BLUE | YELLOW; //7
	nnn = BLUE + YELLOW; //7
	nnn = 1 | 6; //7

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции 
	//myColors = 1; 	Ошибка	C2440: тип int невозможно преобразовать в main::eColors
	myColors = static_cast<eColors>(1);	//модифицируйте выражение таким образом, чтобы компилятор не выдавал ошибки
	//М. Полубенцева (стр.79-80)
	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?
	myColors = static_cast<eColors>(123);
	stop


		// *******************************************************
			// Задание 6.1 Логический тип bool
			// Выполняя задание по шагам, следите за значениями
			// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

		int nNumber = 1;
	bool b = (nNumber != 0); //b=true(1), так как утверждение 1!=0 верно
	b = (nNumber == 0); //b=false(0), так как утверждение 1==0 неверно
	b = (nNumber > 0); //b=true(1), так как утверждение 1>0 верно
	b = (nNumber > 1); //b=false(0), так как утверждение 1>1 неверно
	b = 5; //b=true(1)

	//Вы всегда можете преобразовать логическое значение к целому
	//явно или компилятор может это сделать самостоятельно (неявно)
	//Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp = b + 1; //b=true=1 -> 1+1=2

	//Задание 6.2 В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным не является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.
	// Примечание: НЕ НАДО пользоваться операторами if-else, тернарным оператором и switch
	//             НАДО написать логическое выражение в одну строку.
	{
		int year = 1823;
		//int year = 1824;
		//int year = 1900;
		//int year = 2000;

		//Вычислили значение 
		bool isLeapYear = ((year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0));
		// проверили значение в отладчике
		stop
	}

	// *******************************************************
		// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

			//const int nN; //объект типа const нужно инициализировать при определении 
			//nN = 1; //nN объявлена как константа -> ей невозможно присвоить значение переменной
	}



	// ********************************************************
		//Задание 8. Логические условные операторы и операторы отношения.

		//Задание 8.1 Напишите фрагмент кода, который переводит код символа, 
		//хранящийся в переменной ch в противоположный регистр.
		//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
		//или нажал другую клавишу, которой символ не соответствует
		//Подсказка: работаем только с символами английского алфавита, для которого в таблице
		// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
		// соответствующей буквы верхнего регистра.
	const int REGISTER_DIFFERENCE = 0x20;
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		//https://metanit.com/cpp/tutorial/2.10.php источник
		char ch;
		std::cout << "task 8.1" << std::endl;
		std::cout << "input latin letter" << std::endl;
		std::cin >> ch;
		//... изменили регистр
		if ((ch >= 'A') and (ch <= 'Z')) ch = ch + REGISTER_DIFFERENCE;
		else if ((ch >= 'a') and (ch <= 'z')) ch = ch - REGISTER_DIFFERENCE;
		else std::cout << "impossible, it's not latin letter" << std::endl;
		// здесь проверили в отладчике значение или вывели "эхо" на экран
		std::cout << ch << std::endl;
		stop
	}


	//Задание 8.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	//x, y могут быть int, float, double
	// код по аналогии с Полубенцевой (стр 116)
	{
		float x = 1.99;
		float y = 1.22;
		if (x <= 0) y = 0;
		else if (x >= 1) y = 1;
		else y = x;
		
		stop;
	}

	//Задание 8.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: в переменной cInput типа char дано значение символа,
	//введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		char ch;
		int x;
		int y = 0;
		std::cout << "task 8.3" << std::endl;
		std::cout << "input x" << std::endl;
		std::cin >> x;
		std::cout << "input ch" << std::endl;
		std::cin >> ch;
		//сформировали значение
		switch (ch)
		{
		case 'y':
		case 'Y':
			y = x;
			break;
		case 'n':
		case 'N':
			y = x * 2;
			break;
		default:
			std::cout << "error" << std::endl;
		}
		std::cout << y << std::endl;
	}
	// ********************************************************
	//Задание 9. Циклы.

	//Задание 9.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Введите границы с помощью потока ввода или с помощью средств отладки.
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
		//сформировать границы диапазона
		std::cout << "task 9.1" << std::endl;
		int a, b;
		std::cout << "input smallest number of range" << std::endl;
		std::cin >> a;
		std::cout << "input biggest number of range" << std::endl;
		std::cin >> b;
		int summ = 0;
		//проверить корректность значений
		if (a >= b) std::cout << "ERROR: choose smaller value" << std::endl;
		// вычислить сумму
		for (a; a <= b; a++)
			{
				if (a > b) break;
				summ += a;
			}
		// проверить в отладчике значение
		std::cout <<"Sum = "<< summ << std::endl;
		
		stop
	}


	//Задание 9.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.
	
	{
		std::cout << "task 9.2" << std::endl;
		int a;
		do
		{
			std::cin >> a;
		} while (not((a>=10) and ((a&1)==0)));
		std::cout << "the end" << std::endl;


	}
	
	//Задание 9.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		std::cout << "task 9.3" << std::endl;
		int x = 0;
		float sum = 0;
		while (sum <= 1.7)
		{
			x += 1;
			//sum += 1 / static_cast<float>(x);
			sum += 1.f / x;
		}
		std::cout << x << std::endl;
	}
	return 0;//код завершения приложения
}	// Конец функции main()
